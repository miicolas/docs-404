---
title: Les Watchers en Vue.js
description: Apprenez √† surveiller les changements de donn√©es et √† r√©agir en cons√©quence √† l'aide des watchers en Vue.js.
---

import { File, Folder, Files } from 'fumadocs-ui/components/files';
import { Step, Steps } from 'fumadocs-ui/components/steps';
import { Tab, Tabs } from 'fumadocs-ui/components/tabs';
import { Callout } from 'fumadocs-ui/components/callout';

## Introduction aux Watchers

<Callout type="info">
  Les watchers sont des fonctions sp√©ciales qui vous permettent de surveiller les changements d'une donn√©e r√©active et d'ex√©cuter du code en r√©action √† ces changements.
</Callout>

## Watchers vs Computed Properties

<Cards>
  <Card title="Computed Properties" icon="üßÆ">
    - Calculer des valeurs d√©riv√©es en fonction d'autres donn√©es
    - Mises en cache et r√©actives
    - Id√©ales pour les transformations de donn√©es
  </Card>
  <Card title="Watchers" icon="üëÄ">
    - R√©agir aux changements avec des effets secondaires
    - Id√©aux pour les op√©rations asynchrones
    - Permettent l'acc√®s aux valeurs pr√©c√©dentes et actuelles
  </Card>
</Cards>

## Watchers Simples

<Tabs items={['composition', 'options']}>
  <Tab label="Composition API" value="composition">
    ```vue showLineNumbers
    <script setup>
    import { ref, watch } from 'vue'
    
    const message = ref('Hello Vue!')
    
    // Surveiller une propri√©t√© r√©active
    watch(message, (newValue, oldValue) => {
      console.log('Message chang√©:')
      console.log('Nouvelle valeur:', newValue)
      console.log('Ancienne valeur:', oldValue)
    })
    
    function updateMessage() {
      message.value = 'Message mis √† jour √† ' + new Date().toLocaleTimeString()
    }
    </script>
    
    <template>
      <div>
        <p>{{ message }}</p>
        <button @click="updateMessage">Mettre √† jour</button>
      </div>
    </template>
    ```
  </Tab>
  <Tab label="Options API" value="options">
    ```vue showLineNumbers
    <script>
    export default {
      data() {
        return {
          message: 'Hello Vue!'
        }
      },
      
      // D√©clarer les watchers dans l'option "watch"
      watch: {
        message(newValue, oldValue) {
          console.log('Message chang√©:')
          console.log('Nouvelle valeur:', newValue)
          console.log('Ancienne valeur:', oldValue)
        }
      },
      
      methods: {
        updateMessage() {
          this.message = 'Message mis √† jour √† ' + new Date().toLocaleTimeString()
        }
      }
    }
    </script>
    
    <template>
      <div>
        <p>{{ message }}</p>
        <button @click="updateMessage">Mettre √† jour</button>
      </div>
    </template>
    ```
  </Tab>
</Tabs>

## Surveiller des Sources de Donn√©es Complexes

### Surveiller un Objet

```vue showLineNumbers
<script setup>
import { reactive, watch } from 'vue'

const user = reactive({
  name: 'Alice',
  age: 25,
  address: {
    city: 'Paris',
    country: 'France'
  }
})

// Surveiller l'objet entier (par d√©faut, surveillance non profonde)
watch(user, (newValue, oldValue) => {
  console.log('Utilisateur mis √† jour:', newValue)
  
  // ‚ö†Ô∏è ATTENTION: Dans le cas d'un objet r√©actif (reactive),
  // newValue et oldValue seront identiques car ils font r√©f√©rence
  // au m√™me objet qui a √©t√© modifi√©
}, { deep: false })

// Surveiller l'objet avec deep: true pour d√©tecter les changements imbriqu√©s
watch(user, (newValue) => {
  console.log('Changement d√©tect√© dans l\'objet utilisateur (y compris imbriqu√©):', newValue)
  console.log('Ville:', newValue.address.city)
}, { deep: true })

// Surveiller une propri√©t√© sp√©cifique de l'objet
watch(() => user.age, (newAge, oldAge) => {
  console.log(`L'√¢ge a chang√© de ${oldAge} √† ${newAge}`)
})

// Surveiller une propri√©t√© imbriqu√©e
watch(() => user.address.city, (newCity, oldCity) => {
  console.log(`La ville a chang√© de ${oldCity} √† ${newCity}`)
})
</script>

<template>
  <div>
    <h2>Utilisateur</h2>
    <div>
      <label>Nom: </label>
      <input v-model="user.name">
    </div>
    <div>
      <label>√Çge: </label>
      <input type="number" v-model.number="user.age">
    </div>
    <div>
      <label>Ville: </label>
      <input v-model="user.address.city">
    </div>
    <div>
      <label>Pays: </label>
      <input v-model="user.address.country">
    </div>
  </div>
</template>
```

### Surveiller Plusieurs Sources

```vue showLineNumbers
<script setup>
import { ref, watch } from 'vue'

const firstName = ref('Jean')
const lastName = ref('Dupont')
const age = ref(30)

// Surveiller plusieurs sources √† la fois
watch([firstName, lastName], ([newFirstName, newLastName], [oldFirstName, oldLastName]) => {
  console.log(
    `Le nom a chang√© de ${oldFirstName} ${oldLastName} √† ${newFirstName} ${newLastName}`
  )
})

// Surveiller 3 sources avec une fonction de callback commune
watch([firstName, lastName, age], (newValues, oldValues) => {
  console.log('Nouvelles valeurs:', newValues)
  console.log('Anciennes valeurs:', oldValues)
  
  const [newFirstName, newLastName, newAge] = newValues
  const [oldFirstName, oldLastName, oldAge] = oldValues
  
  const changes = []
  if (newFirstName !== oldFirstName) changes.push('pr√©nom')
  if (newLastName !== oldLastName) changes.push('nom')
  if (newAge !== oldAge) changes.push('√¢ge')
  
  console.log(`Changements d√©tect√©s: ${changes.join(', ')}`)
})
</script>

<template>
  <div>
    <div>
      <label>Pr√©nom: </label>
      <input v-model="firstName">
    </div>
    <div>
      <label>Nom: </label>
      <input v-model="lastName">
    </div>
    <div>
      <label>√Çge: </label>
      <input type="number" v-model.number="age">
    </div>
  </div>
</template>
```

## Watchers Imm√©diats 

<Callout type="info">
  Par d√©faut, les watchers sont d√©clench√©s uniquement lorsque la valeur surveill√©e change. Avec l'option `immediate: true`, le watcher s'ex√©cute √©galement d√®s sa cr√©ation.
</Callout>

```vue showLineNumbers
<script setup>
import { ref, watch } from 'vue'

const searchQuery = ref('')
const searchResults = ref([])
const loading = ref(false)

// Watcher imm√©diat qui se d√©clenche d√®s la cr√©ation
watch(searchQuery, async (newQuery) => {
  if (newQuery.trim() === '') {
    searchResults.value = []
    return
  }
  
  loading.value = true
  try {
    // Simulation d'une requ√™te API
    const response = await fetch(`https://api.example.com/search?q=${newQuery}`)
    searchResults.value = await response.json()
  } catch (error) {
    console.error('Erreur de recherche:', error)
    searchResults.value = []
  } finally {
    loading.value = false
  }
}, { immediate: true }) // ‚Üê Le watcher s'ex√©cute imm√©diatement
</script>

<template>
  <div>
    <input 
      v-model="searchQuery" 
      placeholder="Rechercher..."
      type="search"
    />
    
    <div v-if="loading">Chargement...</div>
    
    <ul v-else-if="searchResults.length > 0">
      <li v-for="result in searchResults" :key="result.id">
        {{ result.title }}
      </li>
    </ul>
    
    <p v-else-if="searchQuery.trim() && !loading">
      Aucun r√©sultat trouv√©.
    </p>
  </div>
</template>
```

## Options Additionnelles des Watchers

<Cards>
  <Card title="deep" icon="üîç">
    Surveiller de mani√®re r√©cursive les propri√©t√©s imbriqu√©es d'un objet
  </Card>
  <Card title="immediate" icon="‚ö°">
    Ex√©cuter le watcher imm√©diatement lors de sa cr√©ation
  </Card>
  <Card title="flush" icon="üîÑ">
    Contr√¥ler le timing de l'ex√©cution du watcher (`'pre'`, `'post'`, `'sync'`)
  </Card>
  <Card title="onTrack/onTrigger" icon="üêõ">
    Hooks de d√©bogage pour comprendre quand le watcher est d√©clench√©
  </Card>
</Cards>

```vue showLineNumbers
<script setup>
import { reactive, watch } from 'vue'

const state = reactive({
  nested: {
    count: 0
  },
  items: ['a', 'b', 'c']
})

// Exemple complet avec plusieurs options
watch(
  () => state,
  (newValue, oldValue) => {
    console.log('√âtat chang√©:', newValue)
  },
  {
    deep: true,        // Surveillance profonde
    immediate: true,   // Ex√©cution imm√©diate
    flush: 'post',     // Ex√©cuter apr√®s la mise √† jour du DOM
    
    // Hooks de d√©bogage (en mode d√©veloppement uniquement)
    onTrack(event) {
      console.log('Propri√©t√© suivie:', event)
    },
    onTrigger(event) {
      console.log('D√©clenchement du watcher:', event)
    }
  }
)
</script>
```

## Arr√™ter un Watcher

<Callout type="warning">
  La fonction `watch` retourne une fonction de nettoyage qui peut √™tre appel√©e pour arr√™ter le watcher.
</Callout>

```vue showLineNumbers
<script setup>
import { ref, watch, onBeforeUnmount } from 'vue'

const count = ref(0)
const isWatching = ref(true)

// Cr√©er un watcher et stocker la fonction d'arr√™t
const stopWatcher = watch(count, (newValue) => {
  console.log('Le compteur a chang√©:', newValue)
  
  // Arr√™ter le watcher apr√®s un certain seuil
  if (newValue >= 5) {
    stopWatcher() // Arr√™ter manuellement
    isWatching.value = false
    console.log('Watcher arr√™t√© car le seuil de 5 est atteint')
  }
})

// Autre watcher pour d√©montrer l'arr√™t dans onBeforeUnmount
const anotherWatcher = watch(isWatching, (value) => {
  console.log('√âtat de surveillance chang√©:', value)
})

onBeforeUnmount(() => {
  // Nettoyage des watchers avant le d√©montage du composant
  stopWatcher() // Si ce n'est pas d√©j√† fait
  anotherWatcher() // Arr√™ter le second watcher
})

function increment() {
  count.value++
}

function restartWatching() {
  // Red√©marrer le watcher en cr√©ant un nouveau
  if (!isWatching.value) {
    const newStopWatcher = watch(count, (newValue) => {
      console.log('Nouveau watcher: compteur chang√© √†', newValue)
    })
    
    // Remplacer la fonction d'arr√™t
    stopWatcher = newStopWatcher
    isWatching.value = true
  }
}
</script>

<template>
  <div>
    <p>Compteur: {{ count }}</p>
    <p>Surveillance active: {{ isWatching }}</p>
    
    <button @click="increment">Incr√©menter</button>
    <button @click="restartWatching" :disabled="isWatching">
      Red√©marrer la surveillance
    </button>
  </div>
</template>
```

## watchEffect - Surveillance Automatique des D√©pendances

<Callout type="info">
  `watchEffect` est une alternative plus concise √† `watch` qui surveille automatiquement toutes les d√©pendances r√©actives utilis√©es dans sa fonction de callback.
</Callout>

```vue showLineNumbers
<script setup>
import { ref, reactive, watchEffect } from 'vue'

const userId = ref(1)
const user = reactive({
  name: '',
  email: ''
})
const loading = ref(false)

// watchEffect surveille automatiquement toutes les d√©pendances r√©actives
// utilis√©es √† l'int√©rieur de sa fonction
watchEffect(async () => {
  // userId.value est automatiquement surveill√©
  const id = userId.value
  
  if (id <= 0) return
  
  loading.value = true
  try {
    const response = await fetch(`https://jsonplaceholder.typicode.com/users/${id}`)
    const data = await response.json()
    
    // Mise √† jour des propri√©t√©s r√©actives
    user.name = data.name
    user.email = data.email
  } catch (error) {
    console.error('Erreur lors du chargement:', error)
  } finally {
    loading.value = false
  }
})

function changeUser(id) {
  userId.value = id
}
</script>

<template>
  <div>
    <h2>D√©tails de l'utilisateur</h2>
    
    <div class="user-selector">
      <button @click="changeUser(1)">Utilisateur 1</button>
      <button @click="changeUser(2)">Utilisateur 2</button>
      <button @click="changeUser(3)">Utilisateur 3</button>
    </div>
    
    <div v-if="loading">Chargement...</div>
    
    <div v-else class="user-details">
      <p><strong>ID:</strong> {{ userId }}</p>
      <p><strong>Nom:</strong> {{ user.name }}</p>
      <p><strong>Email:</strong> {{ user.email }}</p>
    </div>
  </div>
</template>
```

## watchPostEffect et watchSyncEffect

<Callout type="info">
  Vue fournit √©galement des variantes de `watchEffect` avec diff√©rents timings d'ex√©cution.
</Callout>

```vue showLineNumbers
<script setup>
import { ref, watchEffect, watchPostEffect, watchSyncEffect } from 'vue'

const count = ref(0)
const element = ref(null)

// Ex√©cut√© avant les mises √† jour du DOM (par d√©faut)
watchEffect(() => {
  console.log('watchEffect - count:', count.value)
  // Ne peut pas acc√©der aux changements DOM actualis√©s
})

// Ex√©cut√© apr√®s les mises √† jour du DOM
watchPostEffect(() => {
  console.log('watchPostEffect - count:', count.value)
  // Peut acc√©der aux changements DOM actualis√©s
  if (element.value) {
    console.log('Hauteur de l\'√©l√©ment:', element.value.offsetHeight)
  }
})

// Ex√©cut√© de mani√®re synchrone
watchSyncEffect(() => {
  console.log('watchSyncEffect - count:', count.value)
  // Attention: Peut causer plusieurs rendus en cascade si utilis√© incorrectement
})
</script>

<template>
  <div>
    <p ref="element">Compteur: {{ count }}</p>
    <button @click="count++">Incr√©menter</button>
  </div>
</template>
```

## Gestion des Erreurs dans les Watchers

```vue showLineNumbers
<script setup>
import { ref, watch } from 'vue'

const userData = ref('')
const error = ref(null)

// Watcher avec gestion d'erreurs
watch(userData, async (newData) => {
  if (!newData.trim()) return
  
  error.value = null
  
  try {
    // Simulation d'une op√©ration risqu√©e
    if (newData === 'error') {
      throw new Error('Donn√©es invalides')
    }
    
    // Traitement r√©ussi
    console.log('Donn√©es trait√©es avec succ√®s:', newData)
  } catch (err) {
    // Gestion de l'erreur
    console.error('Erreur dans le watcher:', err)
    error.value = err.message
  }
})
</script>

<template>
  <div>
    <input v-model="userData" placeholder="Entrez des donn√©es...">
    <p>Entrez 'error' pour simuler une erreur</p>
    
    <div v-if="error" class="error">
      Erreur: {{ error }}
    </div>
  </div>
</template>

<style>
.error {
  color: red;
  border: 1px solid red;
  padding: 8px;
  margin-top: 10px;
  border-radius: 4px;
}
</style>
```

## Exercice Pratique

<Callout type="info">
  Cr√©ez un g√©n√©rateur de mots de passe avec watchers pour valider la force du mot de passe en temps r√©el.
</Callout>

```vue showLineNumbers
<script setup>
import { ref, reactive, computed, watch } from 'vue'

// √âtat du formulaire
const passwordForm = reactive({
  password: '',
  length: 12,
  includeNumbers: true,
  includeSymbols: true,
  includeUppercase: true
})

// √âtat de validation
const passwordStrength = ref(0)
const strengthText = ref('')
const strengthColor = ref('')
const validationIssues = ref([])

// G√©n√©rer un mot de passe al√©atoire
function generatePassword() {
  const uppercaseChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
  const lowercaseChars = 'abcdefghijklmnopqrstuvwxyz'
  const numberChars = '0123456789'
  const symbolChars = '!@#$%^&*()_+[]{}|;:,.<>?'
  
  let chars = lowercaseChars
  if (passwordForm.includeUppercase) chars += uppercaseChars
  if (passwordForm.includeNumbers) chars += numberChars
  if (passwordForm.includeSymbols) chars += symbolChars
  
  let password = ''
  for (let i = 0; i < passwordForm.length; i++) {
    const randomIndex = Math.floor(Math.random() * chars.length)
    password += chars[randomIndex]
  }
  
  passwordForm.password = password
}

// Surveiller les changements de mot de passe pour l'√©valuation
watch(() => passwordForm.password, (newPassword) => {
  // R√©initialiser les probl√®mes de validation
  validationIssues.value = []
  
  // V√©rifier la longueur
  if (newPassword.length < 8) {
    validationIssues.value.push('Le mot de passe doit contenir au moins 8 caract√®res')
  }
  
  // V√©rifier la pr√©sence de chiffres
  if (!/\d/.test(newPassword)) {
    validationIssues.value.push('Le mot de passe doit contenir au moins un chiffre')
  }
  
  // V√©rifier la pr√©sence de lettres majuscules
  if (!/[A-Z]/.test(newPassword)) {
    validationIssues.value.push('Le mot de passe doit contenir au moins une lettre majuscule')
  }
  
  // V√©rifier la pr√©sence de symboles
  if (!/[^A-Za-z0-9]/.test(newPassword)) {
    validationIssues.value.push('Le mot de passe doit contenir au moins un symbole')
  }
  
  // Calculer la force du mot de passe
  calculatePasswordStrength(newPassword)
})

// Surveiller les options pour g√©n√©rer automatiquement un nouveau mot de passe
watch(
  [
    () => passwordForm.length,
    () => passwordForm.includeNumbers,
    () => passwordForm.includeSymbols,
    () => passwordForm.includeUppercase
  ],
  () => {
    generatePassword()
  }
)

// Calculer la force du mot de passe
function calculatePasswordStrength(password) {
  if (!password) {
    passwordStrength.value = 0
    strengthText.value = ''
    strengthColor.value = ''
    return
  }
  
  let strength = 0
  
  // Longueur
  strength += Math.min(6, Math.floor(password.length / 3))
  
  // Complexit√©
  if (/[A-Z]/.test(password)) strength += 1
  if (/[a-z]/.test(password)) strength += 1
  if (/\d/.test(password)) strength += 1
  if (/[^A-Za-z0-9]/.test(password)) strength += 1
  
  // Vari√©t√© de caract√®res
  const uniqueChars = new Set(password.split('')).size
  strength += Math.min(2, Math.floor(uniqueChars / 4))
  
  // Score final (max 10)
  passwordStrength.value = Math.min(10, strength)
  
  // Texte et couleur bas√©s sur la force
  if (passwordStrength.value <= 3) {
    strengthText.value = 'Faible'
    strengthColor.value = '#ff4d4d'
  } else if (passwordStrength.value <= 6) {
    strengthText.value = 'Moyen'
    strengthColor.value = '#ffaa00'
  } else if (passwordStrength.value <= 8) {
    strengthText.value = 'Fort'
    strengthColor.value = '#00cc00'
  } else {
    strengthText.value = 'Tr√®s fort'
    strengthColor.value = '#00aa00'
  }
}

// G√©n√©rer un mot de passe initial
generatePassword()
</script>

<template>
  <div class="password-generator">
    <h2>G√©n√©rateur de Mot de Passe</h2>
    
    <div class="password-display">
      <input 
        type="text" 
        v-model="passwordForm.password"
        readonly
      >
      <button @click="generatePassword">G√©n√©rer</button>
    </div>
    
    <div class="strength-meter">
      <div class="strength-label">
        Force : 
        <span :style="{ color: strengthColor }">{{ strengthText }}</span>
      </div>
      <div class="strength-bar">
        <div 
          class="strength-progress" 
          :style="{ 
            width: `${passwordStrength * 10}%`, 
            backgroundColor: strengthColor 
          }"
        ></div>
      </div>
    </div>
    
    <div v-if="validationIssues.length > 0" class="validation-issues">
      <ul>
        <li v-for="(issue, index) in validationIssues" :key="index">
          {{ issue }}
        </li>
      </ul>
    </div>
    
    <div class="options">
      <div class="option">
        <label>Longueur: {{ passwordForm.length }}</label>
        <input 
          type="range" 
          v-model.number="passwordForm.length" 
          min="6" 
          max="30"
        >
      </div>
      
      <div class="option">
        <label>
          <input 
            type="checkbox" 
            v-model="passwordForm.includeUppercase"
          >
          Inclure des majuscules (A-Z)
        </label>
      </div>
      
      <div class="option">
        <label>
          <input 
            type="checkbox" 
            v-model="passwordForm.includeNumbers"
          >
          Inclure des chiffres (0-9)
        </label>
      </div>
      
      <div class="option">
        <label>
          <input 
            type="checkbox" 
            v-model="passwordForm.includeSymbols"
          >
          Inclure des symboles (!@#$%^&*)
        </label>
      </div>
    </div>
  </div>
</template>

<style scoped>
.password-generator {
  max-width: 500px;
  margin: 0 auto;
  padding: 20px;
  border: 1px solid #ddd;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.password-display {
  display: flex;
  margin-bottom: 20px;
}

.password-display input {
  flex: 1;
  padding: 10px;
  font-family: monospace;
  font-size: 16px;
  border: 1px solid #ddd;
  border-radius: 4px 0 0 4px;
}

.password-display button {
  padding: 10px 15px;
  background-color: #4CAF50;
  color: white;
  border: none;
  border-radius: 0 4px 4px 0;
  cursor: pointer;
}

.strength-meter {
  margin-bottom: 20px;
}

.strength-label {
  margin-bottom: 5px;
}

.strength-bar {
  height: 10px;
  background-color: #f0f0f0;
  border-radius: 5px;
  overflow: hidden;
}

.strength-progress {
  height: 100%;
  transition: width 0.3s, background-color 0.3s;
}

.validation-issues {
  background-color: #fff8f8;
  padding: 10px;
  margin-bottom: 20px;
  border: 1px solid #ffcccc;
  border-radius: 4px;
}

.validation-issues ul {
  margin: 0;
  padding-left: 20px;
}

.validation-issues li {
  color: #cc0000;
}

.options {
  border-top: 1px solid #eee;
  padding-top: 15px;
}

.option {
  margin-bottom: 10px;
}

.option label {
  display: flex;
  align-items: center;
  gap: 8px;
}

.option input[type="range"] {
  width: 100%;
  margin-top: 5px;
}
</style>
```

## Bonnes Pratiques

<Cards>
  <Card title="Garder les Watchers Simples" icon="‚ö°">
    √âvitez la logique trop complexe dans un seul watcher
  </Card>
  <Card title="√âviter les Boucles Infinies" icon="üîÑ">
    Attention √† ne pas modifier une propri√©t√© observ√©e dans son propre watcher
  </Card>
  <Card title="Pr√©f√©rer Computed Quand Possible" icon="üßÆ">
    Pour de simples d√©rivations, utilisez des propri√©t√©s computed
  </Card>
  <Card title="Nettoyage Appropri√©" icon="üßπ">
    Arr√™tez les watchers qui ne sont plus n√©cessaires
  </Card>
</Cards>

## Prochaines √âtapes

<Cards>
  <Card title="Composants" href="composants" icon="üß©">
    D√©couvrez comment cr√©er et utiliser des composants r√©utilisables
  </Card>
  <Card title="Props" href="props" icon="üîÑ">
    Apprenez √† passer des donn√©es aux composants enfants
  </Card>
</Cards> 
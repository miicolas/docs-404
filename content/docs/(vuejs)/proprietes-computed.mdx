---
title: Propri√©t√©s Computed en Vue.js
description: Apprenez √† utiliser les propri√©t√©s calcul√©es (computed) pour cr√©er des valeurs d√©riv√©es r√©actives dans vos composants Vue.js.
---

import { File, Folder, Files } from 'fumadocs-ui/components/files';
import { Step, Steps } from 'fumadocs-ui/components/steps';
import { Tab, Tabs } from 'fumadocs-ui/components/tabs';
import { Callout } from 'fumadocs-ui/components/callout';

## Introduction aux Propri√©t√©s Computed

<Callout type="info">
  Les propri√©t√©s computed sont des valeurs calcul√©es bas√©es sur d'autres propri√©t√©s r√©actives. Elles sont mises en cache et ne sont recalcul√©es que lorsque leurs d√©pendances changent.
</Callout>

## Pourquoi Utiliser des Propri√©t√©s Computed ?

<Cards>
  <Card title="Performance" icon="‚ö°">
    Elles sont mises en cache et ne se recalculent que lorsque n√©cessaire
  </Card>
  <Card title="R√©activit√©" icon="üîÑ">
    Elles se mettent √† jour automatiquement quand leurs d√©pendances changent
  </Card>
  <Card title="Lisibilit√©" icon="üìñ">
    Elles permettent de d√©placer la logique complexe hors des templates
  </Card>
  <Card title="R√©utilisabilit√©" icon="‚ôªÔ∏è">
    Elles peuvent √™tre utilis√©es √† plusieurs endroits dans votre composant
  </Card>
</Cards>

## Propri√©t√©s Computed Basiques

<Tabs items={['basic', 'multiple', 'chained']}>
  <Tab label="Utilisation basique" value="basic">
    ```vue showLineNumbers
    <script setup>
    import { ref, computed } from 'vue'
    
    const firstName = ref('Jean')
    const lastName = ref('Dupont')
    
    // Propri√©t√© computed simple
    const fullName = computed(() => {
      return `${firstName.value} ${lastName.value}`
    })
    </script>
    
    <template>
      <div>
        <input v-model="firstName" placeholder="Pr√©nom">
        <input v-model="lastName" placeholder="Nom">
        <p>Nom complet: {{ fullName }}</p>
      </div>
    </template>
    ```
  </Tab>
  <Tab label="D√©pendances multiples" value="multiple">
    ```vue showLineNumbers
    <script setup>
    import { ref, computed } from 'vue'
    
    const price = ref(100)
    const quantity = ref(2)
    const taxRate = ref(0.2) // 20%
    
    // Propri√©t√© computed avec plusieurs d√©pendances
    const total = computed(() => {
      const subtotal = price.value * quantity.value
      const tax = subtotal * taxRate.value
      return (subtotal + tax).toFixed(2)
    })
    </script>
    
    <template>
      <div>
        <div>
          <label>Prix unitaire: </label>
          <input type="number" v-model.number="price">
        </div>
        <div>
          <label>Quantit√©: </label>
          <input type="number" v-model.number="quantity" min="1">
        </div>
        <div>
          <label>Taux de taxe: </label>
          <input 
            type="range" 
            v-model.number="taxRate" 
            min="0" 
            max="0.5" 
            step="0.01"
          >
          {{ (taxRate * 100).toFixed(0) }}%
        </div>
        <p>Montant total: {{ total }}‚Ç¨</p>
      </div>
    </template>
    ```
  </Tab>
  <Tab label="Propri√©t√©s cha√Æn√©es" value="chained">
    ```vue showLineNumbers
    <script setup>
    import { ref, computed } from 'vue'
    
    const items = ref([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
    const filterValue = ref(3)
    
    // Propri√©t√© computed qui d√©pend d'une autre propri√©t√© computed
    const filteredItems = computed(() => {
      return items.value.filter(item => item > filterValue.value)
    })
    
    const evenFilteredItems = computed(() => {
      return filteredItems.value.filter(item => item % 2 === 0)
    })
    
    const itemsSum = computed(() => {
      return evenFilteredItems.value.reduce((sum, item) => sum + item, 0)
    })
    </script>
    
    <template>
      <div>
        <div>
          <label>Filtrer les valeurs sup√©rieures √†: </label>
          <input type="number" v-model.number="filterValue">
        </div>
        <p>Items filtr√©s: {{ filteredItems.join(', ') }}</p>
        <p>Items pairs filtr√©s: {{ evenFilteredItems.join(', ') }}</p>
        <p>Somme des items pairs filtr√©s: {{ itemsSum }}</p>
      </div>
    </template>
    ```
  </Tab>
</Tabs>

## Propri√©t√©s Computed vs M√©thodes

<Callout type="warning">
  Une m√©thode est appel√©e √† chaque rendu, tandis qu'une propri√©t√© computed est mise en cache et n'est recalcul√©e que si ses d√©pendances changent.
</Callout>

```vue showLineNumbers
<script setup>
import { ref, computed } from 'vue'

const list = ref([1, 2, 3, 4, 5])

// Propri√©t√© computed (avec mise en cache)
const doubledComputed = computed(() => {
  console.log('Propri√©t√© computed calcul√©e')
  return list.value.map(n => n * 2)
})

// M√©thode (sans mise en cache)
function doubledMethod() {
  console.log('M√©thode appel√©e')
  return list.value.map(n => n * 2)
}
</script>

<template>
  <div>
    <button @click="list.push(list.length + 1)">
      Ajouter un nombre
    </button>
    
    <!-- La propri√©t√© computed est calcul√©e une fois puis mise en cache -->
    <p>Computed: {{ doubledComputed }}</p>
    <p>Computed √† nouveau: {{ doubledComputed }}</p>
    
    <!-- La m√©thode est appel√©e √† chaque affichage -->
    <p>M√©thode: {{ doubledMethod() }}</p>
    <p>M√©thode √† nouveau: {{ doubledMethod() }}</p>
  </div>
</template>
```

## Propri√©t√©s Computed avec Getters et Setters

<Callout type="info">
  Par d√©faut, les propri√©t√©s computed sont en lecture seule, mais vous pouvez √©galement d√©finir un setter pour les rendre modifiables.
</Callout>

```vue showLineNumbers
<script setup>
import { ref, computed } from 'vue'

const firstName = ref('Jean')
const lastName = ref('Dupont')

// Propri√©t√© computed avec getter et setter
const fullName = computed({
  // Getter - appel√© quand on acc√®de √† la propri√©t√©
  get() {
    return `${firstName.value} ${lastName.value}`
  },
  // Setter - appel√© quand on assigne une valeur √† la propri√©t√©
  set(newValue) {
    const parts = newValue.split(' ')
    firstName.value = parts[0] || ''
    lastName.value = parts.slice(1).join(' ') || ''
  }
})

function updateFullName() {
  // Ceci appellera le setter
  fullName.value = 'Marie Martin'
}
</script>

<template>
  <div>
    <input v-model="firstName" placeholder="Pr√©nom">
    <input v-model="lastName" placeholder="Nom">
    <p>Nom complet: {{ fullName }}</p>
    
    <input v-model="fullName" placeholder="Nom complet">
    <button @click="updateFullName">Mettre √† jour</button>
  </div>
</template>
```

## Utilisation avec les APIs Options

<Callout type="info">
  Si vous utilisez l'API Options de Vue.js, les propri√©t√©s computed se d√©clarent diff√©remment mais fonctionnent de fa√ßon similaire.
</Callout>

```vue showLineNumbers
<!-- Avec l'API Options -->
<script>
export default {
  data() {
    return {
      firstName: 'Jean',
      lastName: 'Dupont',
      price: 100,
      quantity: 2
    }
  },
  computed: {
    // Propri√©t√© en lecture seule
    fullName() {
      return `${this.firstName} ${this.lastName}`
    },
    
    // Propri√©t√© avec getter et setter
    totalWithTax: {
      get() {
        return this.price * this.quantity * 1.2
      },
      set(newValue) {
        this.price = newValue / (this.quantity * 1.2)
      }
    }
  }
}
</script>
```

## Cas d'Utilisation Concrets

### 1. Filtrage et Tri de Liste

```vue showLineNumbers
<script setup>
import { ref, computed } from 'vue'

const todos = ref([
  { id: 1, text: 'Apprendre Vue', completed: false, priority: 'high' },
  { id: 2, text: 'Cr√©er un composant', completed: true, priority: 'medium' },
  { id: 3, text: 'Optimiser l\'application', completed: false, priority: 'high' },
  { id: 4, text: 'D√©ployer le projet', completed: false, priority: 'low' }
])

const hideCompleted = ref(false)
const filterPriority = ref('all')
const sortBy = ref('priority')

const filteredAndSortedTodos = computed(() => {
  // Filtrage
  let result = todos.value
  
  if (hideCompleted.value) {
    result = result.filter(todo => !todo.completed)
  }
  
  if (filterPriority.value !== 'all') {
    result = result.filter(todo => todo.priority === filterPriority.value)
  }
  
  // Tri
  return [...result].sort((a, b) => {
    if (sortBy.value === 'priority') {
      const priorityOrder = { high: 1, medium: 2, low: 3 }
      return priorityOrder[a.priority] - priorityOrder[b.priority]
    } else {
      // Tri par texte
      return a.text.localeCompare(b.text)
    }
  })
})

const todoSummary = computed(() => {
  const completed = todos.value.filter(t => t.completed).length
  const total = todos.value.length
  return `${completed} termin√©e(s) sur ${total} t√¢che(s)`
})
</script>

<template>
  <div>
    <div class="filters">
      <label>
        <input type="checkbox" v-model="hideCompleted">
        Masquer les t√¢ches termin√©es
      </label>
      
      <select v-model="filterPriority">
        <option value="all">Toutes les priorit√©s</option>
        <option value="high">Haute</option>
        <option value="medium">Moyenne</option>
        <option value="low">Basse</option>
      </select>
      
      <select v-model="sortBy">
        <option value="priority">Trier par priorit√©</option>
        <option value="text">Trier par nom</option>
      </select>
    </div>
    
    <p>{{ todoSummary }}</p>
    
    <ul>
      <li 
        v-for="todo in filteredAndSortedTodos" 
        :key="todo.id"
        :class="{ completed: todo.completed }"
      >
        <input type="checkbox" v-model="todo.completed">
        {{ todo.text }}
        <span class="badge" :class="todo.priority">
          {{ todo.priority }}
        </span>
      </li>
    </ul>
  </div>
</template>

<style scoped>
.completed {
  text-decoration: line-through;
  opacity: 0.7;
}
.badge {
  padding: 2px 6px;
  border-radius: 4px;
  font-size: 0.8em;
  margin-left: 5px;
}
.high { background-color: #f44336; color: white; }
.medium { background-color: #ff9800; color: white; }
.low { background-color: #4caf50; color: white; }
</style>
```

### 2. Validation de Formulaire

```vue showLineNumbers
<script setup>
import { ref, computed } from 'vue'

const username = ref('')
const password = ref('')
const confirmPassword = ref('')

const usernameError = computed(() => {
  if (!username.value) return 'Le nom d\'utilisateur est requis'
  if (username.value.length < 3) return 'Le nom d\'utilisateur doit contenir au moins 3 caract√®res'
  return ''
})

const passwordError = computed(() => {
  if (!password.value) return 'Le mot de passe est requis'
  if (password.value.length < 8) return 'Le mot de passe doit contenir au moins 8 caract√®res'
  if (!/[A-Z]/.test(password.value)) return 'Le mot de passe doit contenir au moins une majuscule'
  if (!/\d/.test(password.value)) return 'Le mot de passe doit contenir au moins un chiffre'
  return ''
})

const confirmPasswordError = computed(() => {
  if (!confirmPassword.value) return 'Veuillez confirmer le mot de passe'
  if (confirmPassword.value !== password.value) return 'Les mots de passe ne correspondent pas'
  return ''
})

const isFormValid = computed(() => {
  return !usernameError.value && 
         !passwordError.value && 
         !confirmPasswordError.value && 
         username.value && 
         password.value && 
         confirmPassword.value
})
</script>

<template>
  <form @submit.prevent="submitForm">
    <div class="form-group">
      <label for="username">Nom d'utilisateur:</label>
      <input id="username" v-model="username" type="text">
      <span v-if="usernameError" class="error">{{ usernameError }}</span>
    </div>
    
    <div class="form-group">
      <label for="password">Mot de passe:</label>
      <input id="password" v-model="password" type="password">
      <span v-if="passwordError" class="error">{{ passwordError }}</span>
    </div>
    
    <div class="form-group">
      <label for="confirm-password">Confirmer le mot de passe:</label>
      <input id="confirm-password" v-model="confirmPassword" type="password">
      <span v-if="confirmPasswordError" class="error">{{ confirmPasswordError }}</span>
    </div>
    
    <button type="submit" :disabled="!isFormValid">S'inscrire</button>
  </form>
</template>

<style scoped>
.form-group {
  margin-bottom: 15px;
}
.error {
  color: red;
  font-size: 0.8em;
  display: block;
  margin-top: 5px;
}
button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}
</style>
```

## Exercice Pratique

<Callout type="info">
  Cr√©ez un calculateur de devises utilisant des propri√©t√©s computed.
</Callout>

```vue showLineNumbers
<script setup>
import { ref, computed } from 'vue'

const amount = ref(100)
const fromCurrency = ref('EUR')
const toCurrency = ref('USD')

// Taux de change (simplifi√©s)
const exchangeRates = {
  EUR: { USD: 1.1, GBP: 0.85, JPY: 160.5 },
  USD: { EUR: 0.91, GBP: 0.77, JPY: 146.8 },
  GBP: { EUR: 1.18, USD: 1.29, JPY: 190.2 },
  JPY: { EUR: 0.0062, USD: 0.0068, GBP: 0.0053 }
}

const availableCurrencies = computed(() => {
  return Object.keys(exchangeRates)
})

const convertedAmount = computed(() => {
  if (fromCurrency.value === toCurrency.value) {
    return amount.value
  }
  
  const rate = exchangeRates[fromCurrency.value][toCurrency.value]
  return (amount.value * rate).toFixed(2)
})

const currencySymbol = computed(() => {
  const symbols = {
    EUR: '‚Ç¨',
    USD: '$',
    GBP: '¬£',
    JPY: '¬•'
  }
  return symbols[toCurrency.value] || ''
})

const conversionRate = computed(() => {
  if (fromCurrency.value === toCurrency.value) {
    return 1
  }
  return exchangeRates[fromCurrency.value][toCurrency.value]
})

const formattedResult = computed(() => {
  return `${amount.value} ${fromCurrency.value} = ${currencySymbol.value}${convertedAmount.value} ${toCurrency.value}`
})

// Inverser les devises
function swapCurrencies() {
  const temp = fromCurrency.value
  fromCurrency.value = toCurrency.value
  toCurrency.value = temp
}
</script>

<template>
  <div class="currency-converter">
    <h2>Convertisseur de Devises</h2>
    
    <div class="converter-form">
      <div class="amount-input">
        <label for="amount">Montant:</label>
        <input 
          id="amount" 
          type="number" 
          v-model.number="amount" 
          min="0" 
          step="0.01"
        >
      </div>
      
      <div class="currency-selectors">
        <div class="from-currency">
          <label for="from-currency">De:</label>
          <select id="from-currency" v-model="fromCurrency">
            <option 
              v-for="currency in availableCurrencies" 
              :key="currency" 
              :value="currency"
            >
              {{ currency }}
            </option>
          </select>
        </div>
        
        <button class="swap-button" @click="swapCurrencies">
          ‚áÑ
        </button>
        
        <div class="to-currency">
          <label for="to-currency">Vers:</label>
          <select id="to-currency" v-model="toCurrency">
            <option 
              v-for="currency in availableCurrencies" 
              :key="currency" 
              :value="currency"
            >
              {{ currency }}
            </option>
          </select>
        </div>
      </div>
    </div>
    
    <div class="conversion-result">
      <p class="rate-info">1 {{ fromCurrency }} = {{ conversionRate }} {{ toCurrency }}</p>
      <p class="result">{{ formattedResult }}</p>
    </div>
  </div>
</template>

<style scoped>
.currency-converter {
  max-width: 500px;
  margin: 0 auto;
  padding: 20px;
  border: 1px solid #ddd;
  border-radius: 8px;
}

.converter-form {
  display: flex;
  flex-direction: column;
  gap: 15px;
  margin-bottom: 20px;
}

.amount-input {
  display: flex;
  flex-direction: column;
}

.currency-selectors {
  display: flex;
  align-items: flex-end;
  gap: 10px;
}

.from-currency, .to-currency {
  flex: 1;
  display: flex;
  flex-direction: column;
}

.swap-button {
  background-color: #4CAF50;
  color: white;
  border: none;
  border-radius: 4px;
  padding: 8px 15px;
  cursor: pointer;
  font-size: 16px;
  margin-bottom: 5px;
}

label {
  margin-bottom: 5px;
}

input, select {
  padding: 8px;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.conversion-result {
  background-color: #f5f5f5;
  padding: 15px;
  border-radius: 4px;
  text-align: center;
}

.rate-info {
  font-size: 0.9em;
  color: #666;
  margin-bottom: 10px;
}

.result {
  font-size: 1.3em;
  font-weight: bold;
}
</style>
```

## Bonnes Pratiques

<Cards>
  <Card title="Gardez-les Simples" icon="‚ö°">
    Les propri√©t√©s computed doivent rester simples et se concentrer sur une seule responsabilit√©
  </Card>
  <Card title="√âvitez les Effets de Bord" icon="‚ö†Ô∏è">
    Les propri√©t√©s computed ne devraient pas modifier d'autres valeurs
  </Card>
  <Card title="Pr√©f√©rez Computed aux M√©thodes" icon="üîç">
    Pour les valeurs d√©riv√©es qui seront utilis√©es plusieurs fois dans le template
  </Card>
  <Card title="Nommage Descriptif" icon="üìù">
    Utilisez des noms qui d√©crivent clairement ce que la propri√©t√© calcule
  </Card>
</Cards>

## Prochaines √âtapes

<Cards>
  <Card title="Lifecycle Hooks" href="lifecycle-hooks" icon="üîÑ">
    D√©couvrez les hooks du cycle de vie des composants
  </Card>
  <Card title="Watchers" href="watchers" icon="üëÄ">
    Apprenez √† r√©agir aux changements de donn√©es
  </Card>
</Cards> 
---
title: Lifecycle Hooks et Template Refs en Vue.js
description: Apprenez √† utiliser les hooks du cycle de vie des composants et les r√©f√©rences de template pour interagir avec le DOM.
---

import { File, Folder, Files } from 'fumadocs-ui/components/files';
import { Step, Steps } from 'fumadocs-ui/components/steps';
import { Tab, Tabs } from 'fumadocs-ui/components/tabs';
import { Callout } from 'fumadocs-ui/components/callout';

## Introduction aux Lifecycle Hooks

<Callout type="info">
  Les lifecycle hooks (hooks du cycle de vie) sont des fonctions sp√©ciales qui vous permettent d'ex√©cuter du code √† des moments pr√©cis du cycle de vie d'un composant Vue.
</Callout>

## Cycle de Vie d'un Composant

<Steps>
### Phases principales du cycle de vie
1. **Cr√©ation** - Le composant est instanci√© et initialis√©
2. **Montage** - Le composant est ins√©r√© dans le DOM
3. **Mise √† jour** - Le composant est r√©-rendu suite √† des changements d'√©tat
4. **D√©montage** - Le composant est retir√© du DOM
</Steps>

## Hooks Principaux

<Tabs items={['composition', 'options']}>
  <Tab label="Composition API" value="composition">
    ```vue showLineNumbers
    <script setup>
    import { ref, onMounted, onUpdated, onBeforeUnmount, onUnmounted } from 'vue'
    
    const count = ref(0)
    
    // Cr√©ation (pas de hook sp√©cifique dans la Composition API, 
    // le code est ex√©cut√© √† la cr√©ation)
    console.log('Composant en cours de cr√©ation...')
    
    // Appel√© apr√®s que le composant a √©t√© mont√©
    onMounted(() => {
      console.log('Composant mont√©!')
      // Acc√®s au DOM, initialisations de biblioth√®ques externes, etc.
    })
    
    // Appel√© apr√®s une mise √† jour du composant
    onUpdated(() => {
      console.log('Composant mis √† jour!')
      // Acc√©der au DOM mis √† jour
    })
    
    // Appel√© juste avant que le composant ne soit d√©mont√©
    onBeforeUnmount(() => {
      console.log('Composant en cours de d√©montage...')
      // Nettoyage (annuler des √©v√©nements, des timers, etc.)
    })
    
    // Appel√© apr√®s que le composant a √©t√© d√©mont√©
    onUnmounted(() => {
      console.log('Composant d√©mont√©!')
      // Nettoyage final
    })
    </script>
    
    <template>
      <div>
        <p>Compteur: {{ count }}</p>
        <button @click="count++">Incr√©menter</button>
      </div>
    </template>
    ```
  </Tab>
  <Tab label="Options API" value="options">
    ```vue showLineNumbers
    <script>
    export default {
      data() {
        return {
          count: 0
        }
      },
      
      // Appel√©s pendant la phase de cr√©ation
      beforeCreate() {
        console.log('beforeCreate: avant l\'initialisation')
      },
      created() {
        console.log('created: apr√®s l\'initialisation')
        // Les donn√©es sont r√©actives, mais le template n'est pas encore rendu
      },
      
      // Appel√©s pendant la phase de montage
      beforeMount() {
        console.log('beforeMount: avant le premier rendu')
      },
      mounted() {
        console.log('mounted: apr√®s le premier rendu')
        // Le DOM est accessible, initialisations externes
      },
      
      // Appel√©s pendant les mises √† jour
      beforeUpdate() {
        console.log('beforeUpdate: avant la mise √† jour du DOM')
      },
      updated() {
        console.log('updated: apr√®s la mise √† jour du DOM')
        // Le DOM a √©t√© mis √† jour
      },
      
      // Appel√©s pendant le d√©montage
      beforeUnmount() {
        console.log('beforeUnmount: avant le d√©montage')
        // Nettoyage (√©v√©nements, timers, etc.)
      },
      unmounted() {
        console.log('unmounted: apr√®s le d√©montage')
        // Nettoyage final
      }
    }
    </script>
    
    <template>
      <div>
        <p>Compteur: {{ count }}</p>
        <button @click="count++">Incr√©menter</button>
      </div>
    </template>
    ```
  </Tab>
</Tabs>

## Hooks Suppl√©mentaires

<Cards>
  <Card title="onErrorCaptured" icon="üêõ">
    Appel√© lorsqu'une erreur est captur√©e dans un composant enfant
  </Card>
  <Card title="onRenderTracked/onRenderTriggered" icon="üîç">
    Hooks de d√©bogage pour suivre les d√©pendances qui d√©clenchent des rendus
  </Card>
  <Card title="onActivated/onDeactivated" icon="üîÑ">
    Utilis√©s avec `<KeepAlive>` pour les composants mis en cache
  </Card>
  <Card title="onServerPrefetch" icon="üñ•Ô∏è">
    Pour le rendu c√¥t√© serveur, attend que les promesses soient r√©solues
  </Card>
</Cards>

## Cas d'Utilisation Courants

### 1. Initialisation et Nettoyage

```vue showLineNumbers
<script setup>
import { onMounted, onBeforeUnmount } from 'vue'

let intervalId = null

onMounted(() => {
  console.log('Initialisation de l\'intervalle')
  // Cr√©er un timer qui s'ex√©cute toutes les secondes
  intervalId = setInterval(() => {
    console.log('Tick!', new Date().toLocaleTimeString())
  }, 1000)
})

onBeforeUnmount(() => {
  console.log('Nettoyage de l\'intervalle')
  // Nettoyer le timer pour √©viter les fuites de m√©moire
  clearInterval(intervalId)
})
</script>

<template>
  <div>
    <h2>Composant avec timer</h2>
    <p>V√©rifiez la console pour voir les "ticks"</p>
  </div>
</template>
```

### 2. Chargement de donn√©es

```vue showLineNumbers
<script setup>
import { ref, onMounted } from 'vue'

const users = ref([])
const loading = ref(true)
const error = ref(null)

onMounted(async () => {
  try {
    const response = await fetch('https://jsonplaceholder.typicode.com/users')
    
    if (!response.ok) {
      throw new Error(`Erreur HTTP: ${response.status}`)
    }
    
    users.value = await response.json()
  } catch (err) {
    error.value = err.message
    console.error('Erreur de chargement:', err)
  } finally {
    loading.value = false
  }
})
</script>

<template>
  <div>
    <h2>Liste d'utilisateurs</h2>
    
    <div v-if="loading" class="loading">
      Chargement en cours...
    </div>
    
    <div v-else-if="error" class="error">
      Erreur: {{ error }}
    </div>
    
    <ul v-else class="user-list">
      <li v-for="user in users" :key="user.id">
        {{ user.name }} ({{ user.email }})
      </li>
    </ul>
  </div>
</template>
```

## Introduction aux Template Refs

<Callout type="info">
  Les template refs vous permettent d'obtenir une r√©f√©rence directe √† un √©l√©ment du DOM ou √† un composant enfant dans votre template.
</Callout>

## Cr√©ation et Utilisation de Refs

<Tabs items={['composition', 'options']}>
  <Tab label="Composition API" value="composition">
    ```vue showLineNumbers
    <script setup>
    import { ref, onMounted } from 'vue'
    
    // Cr√©ation d'une r√©f√©rence
    const inputRef = ref(null)
    const paragraphRef = ref(null)
    
    onMounted(() => {
      // Acc√®s √† l'√©l√©ment DOM via .value
      inputRef.value.focus()
      console.log('Texte du paragraphe:', paragraphRef.value.textContent)
      
      // Modification directe de l'√©l√©ment
      paragraphRef.value.style.color = 'blue'
    })
    
    function resetInput() {
      // Manipulation de l'√©l√©ment r√©f√©renc√©
      inputRef.value.value = ''
      inputRef.value.focus()
    }
    </script>
    
    <template>
      <div>
        <!-- Attribution de la r√©f√©rence avec l'attribut ref -->
        <input ref="inputRef" type="text" placeholder="Focus automatique">
        <button @click="resetInput">R√©initialiser</button>
        
        <p ref="paragraphRef">Ce texte sera bleu apr√®s le montage</p>
      </div>
    </template>
    ```
  </Tab>
  <Tab label="Options API" value="options">
    ```vue showLineNumbers
    <script>
    export default {
      data() {
        return {
          message: 'Hello Vue!'
        }
      },
      
      mounted() {
        // Acc√®s aux refs via this.$refs
        this.$refs.inputEl.focus()
        
        // Modification du DOM
        this.$refs.paragraphEl.style.fontWeight = 'bold'
      },
      
      methods: {
        resetInput() {
          this.$refs.inputEl.value = ''
          this.$refs.inputEl.focus()
        }
      }
    }
    </script>
    
    <template>
      <div>
        <input ref="inputEl" type="text" placeholder="Focus automatique">
        <button @click="resetInput">R√©initialiser</button>
        
        <p ref="paragraphEl">{{ message }}</p>
      </div>
    </template>
    ```
  </Tab>
</Tabs>

## R√©f√©rence √† des Composants Enfants

```vue showLineNumbers
<!-- ChildComponent.vue -->
<script setup>
import { ref } from 'vue'

const count = ref(0)

// Exposer des m√©thodes au parent
const increment = () => {
  count.value++
}

const reset = () => {
  count.value = 0
}

// Rendre les m√©thodes accessibles au parent
defineExpose({
  increment,
  reset,
  getCount: () => count.value
})
</script>

<template>
  <div class="child-component">
    <h3>Composant Enfant</h3>
    <p>Compteur: {{ count }}</p>
  </div>
</template>

<!-- ParentComponent.vue -->
<script setup>
import { ref, onMounted } from 'vue'
import ChildComponent from './ChildComponent.vue'

const childRef = ref(null)

onMounted(() => {
  // Acc√®s aux m√©thodes expos√©es du composant enfant
  console.log('Valeur initiale:', childRef.value.getCount())
})

function callChildMethod() {
  childRef.value.increment()
}

function resetChild() {
  childRef.value.reset()
}
</script>

<template>
  <div class="parent-component">
    <h2>Composant Parent</h2>
    
    <!-- R√©f√©rence au composant enfant -->
    <ChildComponent ref="childRef" />
    
    <div class="buttons">
      <button @click="callChildMethod">Incr√©menter l'enfant</button>
      <button @click="resetChild">R√©initialiser l'enfant</button>
    </div>
    
    <p>Utilisez ces boutons pour contr√¥ler le compteur de l'enfant</p>
  </div>
</template>
```

## Refs avec v-for

```vue showLineNumbers
<script setup>
import { ref, onMounted } from 'vue'

const items = ref(['Item 1', 'Item 2', 'Item 3', 'Item 4', 'Item 5'])
const itemRefs = ref([])

onMounted(() => {
  console.log('R√©f√©rences aux √©l√©ments:', itemRefs.value)
  
  // Ajouter une classe √† tous les √©l√©ments pairs
  itemRefs.value.forEach((el, index) => {
    if (index % 2 === 1) {
      el.classList.add('highlighted')
    }
  })
})
</script>

<template>
  <ul>
    <li 
      v-for="(item, index) in items" 
      :key="index"
      :ref="(el) => { if (el) itemRefs[index] = el }"
    >
      {{ item }}
    </li>
  </ul>
</template>

<style>
.highlighted {
  background-color: #ffeb3b;
  font-weight: bold;
}
</style>
```

## Int√©gration de Biblioth√®ques Tierces

```vue showLineNumbers
<script setup>
import { ref, onMounted, onBeforeUnmount } from 'vue'

// Supposons que nous voulons int√©grer une biblioth√®que graphique comme Chart.js
const chartRef = ref(null)
let chart = null

const chartData = {
  labels: ['Jan', 'Fev', 'Mar', 'Avr', 'Mai', 'Juin'],
  datasets: [{
    label: 'Ventes 2023',
    data: [12, 19, 3, 5, 2, 3],
    backgroundColor: 'rgba(75, 192, 192, 0.2)',
    borderColor: 'rgba(75, 192, 192, 1)',
    borderWidth: 1
  }]
}

onMounted(() => {
  // Normalement, vous importeriez Chart depuis 'chart.js'
  // import Chart from 'chart.js/auto'
  
  // Simulation de l'initialisation de Chart.js
  console.log('Initialisation du graphique sur:', chartRef.value)
  
  // Le code r√©el ressemblerait √† ceci:
  // chart = new Chart(chartRef.value, {
  //   type: 'bar',
  //   data: chartData,
  //   options: { responsive: true }
  // })
  
  // Simulons l'objet chart pour l'exemple
  chart = {
    update: () => console.log('Graphique mis √† jour'),
    destroy: () => console.log('Graphique d√©truit')
  }
})

function updateChart() {
  // Mise √† jour du graphique existant
  if (chart) {
    // Dans un cas r√©el, vous modifieriez chart.data
    chart.update()
  }
}

onBeforeUnmount(() => {
  // Nettoyage de la biblioth√®que tierce
  if (chart) {
    chart.destroy()
    chart = null
  }
})
</script>

<template>
  <div>
    <h2>Int√©gration de Chart.js</h2>
    
    <!-- Le canvas qui sera utilis√© par Chart.js -->
    <canvas ref="chartRef" width="400" height="200"></canvas>
    
    <button @click="updateChart">Mettre √† jour le graphique</button>
  </div>
</template>
```

## Exercice Pratique

<Callout type="info">
  Cr√©ez un composant d'√©diteur de texte simple avec mise en forme et fonctionnalit√©s en utilisant les refs et lifecycle hooks.
</Callout>

```vue showLineNumbers
<script setup>
import { ref, onMounted, onBeforeUnmount } from 'vue'

const editorRef = ref(null)
const toolbarButtons = ref([
  { name: 'bold', icon: 'B', command: 'bold' },
  { name: 'italic', icon: 'I', command: 'italic' },
  { name: 'underline', icon: 'U', command: 'underline' },
  { name: 'strikethrough', icon: 'S', command: 'strikeThrough' },
  { name: 'link', icon: 'üîó', command: 'createLink' }
])

const content = ref('')
const wordCount = ref(0)
const charCount = ref(0)

// Initialiser l'√©diteur apr√®s le montage
onMounted(() => {
  // Rendre l'√©diteur modifiable
  editorRef.value.contentEditable = 'true'
  
  // Ajouter un √©couteur d'√©v√©nements pour la mise √† jour des statistiques
  editorRef.value.addEventListener('input', updateStats)
  
  // Tester si on peut coller du texte
  document.addEventListener('paste', handlePaste)
})

// Nettoyer les √©couteurs avant le d√©montage
onBeforeUnmount(() => {
  editorRef.value.removeEventListener('input', updateStats)
  document.removeEventListener('paste', handlePaste)
})

// Ex√©cuter une commande d'√©dition
function executeCommand(command) {
  if (command === 'createLink') {
    const url = prompt('Entrez l\'URL:', 'https://')
    if (url) {
      document.execCommand(command, false, url)
    }
  } else {
    document.execCommand(command, false, null)
  }
  // Mettre le focus sur l'√©diteur apr√®s l'ex√©cution de la commande
  editorRef.value.focus()
}

// Mettre √† jour les statistiques de texte
function updateStats() {
  content.value = editorRef.value.innerHTML
  
  // Calculer le nombre de mots
  const text = editorRef.value.innerText || ''
  const words = text.trim() ? text.trim().split(/\s+/) : []
  wordCount.value = words.length
  
  // Calculer le nombre de caract√®res
  charCount.value = text.length
}

// G√©rer le collage de texte pour supprimer le formatage ind√©sirable
function handlePaste(e) {
  if (document.activeElement === editorRef.value) {
    e.preventDefault()
    
    // Obtenir le texte brut du presse-papiers
    const text = (e.clipboardData || window.clipboardData).getData('text')
    
    // Ins√©rer le texte √† la position actuelle
    document.execCommand('insertText', false, text)
  }
}

// Sauvegarder le contenu
function saveContent() {
  localStorage.setItem('editor-content', content.value)
  alert('Contenu sauvegard√©!')
}

// Charger le contenu sauvegard√©
onMounted(() => {
  const savedContent = localStorage.getItem('editor-content')
  if (savedContent) {
    editorRef.value.innerHTML = savedContent
    updateStats()
  }
})
</script>

<template>
  <div class="text-editor">
    <div class="toolbar">
      <button 
        v-for="button in toolbarButtons" 
        :key="button.name"
        @click="executeCommand(button.command)"
        :title="button.name"
      >
        {{ button.icon }}
      </button>
    </div>
    
    <div 
      ref="editorRef"
      class="editor-content"
      placeholder="Commencez √† √©crire ici..."
    ></div>
    
    <div class="editor-footer">
      <div class="stats">
        <span>Mots: {{ wordCount }}</span>
        <span>Caract√®res: {{ charCount }}</span>
      </div>
      <button @click="saveContent" class="save-button">Sauvegarder</button>
    </div>
  </div>
</template>

<style scoped>
.text-editor {
  border: 1px solid #ddd;
  border-radius: 4px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  margin: 20px auto;
  max-width: 700px;
}

.toolbar {
  padding: 10px;
  border-bottom: 1px solid #eee;
  display: flex;
  gap: 5px;
  background-color: #f9f9f9;
}

.toolbar button {
  width: 30px;
  height: 30px;
  border: 1px solid #ddd;
  background-color: white;
  border-radius: 3px;
  cursor: pointer;
}

.toolbar button:hover {
  background-color: #f0f0f0;
}

.editor-content {
  min-height: 200px;
  padding: 15px;
  outline: none;
  overflow-y: auto;
}

.editor-content:empty:before {
  content: attr(placeholder);
  color: #999;
}

.editor-footer {
  padding: 10px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-top: 1px solid #eee;
  background-color: #f9f9f9;
}

.stats {
  color: #666;
  font-size: 0.9em;
}

.stats span {
  margin-right: 15px;
}

.save-button {
  background-color: #4CAF50;
  color: white;
  border: none;
  padding: 6px 12px;
  border-radius: 4px;
  cursor: pointer;
}
</style>
```

## Bonnes Pratiques

<Cards>
  <Card title="Nettoyage Appropri√©" icon="üßπ">
    Utilisez toujours onBeforeUnmount pour nettoyer les ressources (timers, √©couteurs d'√©v√©nements)
  </Card>
  <Card title="Utilisation Minimale du DOM" icon="üîç">
    N'acc√©dez au DOM avec les refs que lorsque c'est vraiment n√©cessaire
  </Card>
  <Card title="S√©paration des Pr√©occupations" icon="üß©">
    Gardez la logique des hooks organis√©e par fonctionnalit√©
  </Card>
  <Card title="defineExpose" icon="üì§">
    Exposez uniquement les m√©thodes et propri√©t√©s n√©cessaires aux composants parents
  </Card>
</Cards>

## Prochaines √âtapes

<Cards>
  <Card title="Watchers" href="watchers" icon="üëÄ">
    Apprenez √† r√©agir aux changements de donn√©es
  </Card>
  <Card title="Composants" href="composants" icon="üß©">
    D√©couvrez comment cr√©er et utiliser des composants r√©utilisables
  </Card>
</Cards> 
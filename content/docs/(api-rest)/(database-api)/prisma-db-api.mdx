---
title: Prisma ORM 
description: Prisma ORM est un ORM (Objet Relationnel Mapping) pour Node.js et TypeScript/JavaScript qui permet de manipuler des bases de donn√©es de mani√®re simple et efficace.
---

import { Callout } from 'fumadocs-ui/components/callout';

L'utilit√© d'un ORM (Objet Relationnel Mapping) est de permettre de manipuler des bases de donn√©es de mani√®re simple et efficace. Il permet de s√©parer les donn√©es de l'application de la structure de la base de donn√©es, ce qui permet de rendre le code plus modulaire et plus facile √† maintenir.

Il existe plusieurs ORM pour Node.js et TypeScript/JavaScript, mais Prisma est l'un des plus populaires. Il est bas√© sur le concept de mod√®le de donn√©es et permet de cr√©er des mod√®les de donn√©es pour les bases de donn√©es de mani√®re simple et efficace.

## Installation

Pour installer Prisma, vous pouvez utiliser la commande suivante :

```package-install
npm install prisma @prisma/client
```

## Utilisation

Pour utiliser Prisma, vous devez d'abord initialiser un projet Prisma en utilisant la commande suivante :

```bash
npx prisma init
```

Une fois install√©, vous pouvez voir qu'un dossier `prisma` a √©t√© cr√©√© dans votre projet. Dans ce dossier, vous trouverez un fichier `schema.prisma` qui contient la d√©finition de votre mod√®le de donn√©es.

Vous avez aussi un `.env` qui contient les informations de connexion √† votre base de donn√©es, qui permet de relier Prisma √† votre base de donn√©es.


Le fichier `schema.prisma` ressemble √† ceci :

```prisma
{
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}
```

Nous, on utilise une base de donn√©es MySQL, donc on va changer le provider en `mysql` :

```prisma
{
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql" // [!code --]
  provider = "mysql" // [!code ++]
  url      = env("DATABASE_URL")
}
```

<Callout type="info" title="Pourquoi utiliser `mysql` ?">

La base de donn√©es MySQL est plus rapide et plus l√©g√®re que la base de donn√©es PostgreSQL, mais elle n'est pas compatible avec tous les navigateurs. Aussi MySQL et Laragon ne supporte pas les bases de donn√©es POSTGRESQL.

</Callout>

## Environnements variables 

Les environnements variables sont des variables d'environnement qui sont d√©finies dans le terminal. Ils sont utilis√©s pour stocker des informations sensibles telles que les mots de passe, les cl√©s API, etc.

Ici nous avons d√©fini une variable `DATABASE_URL` qui contient l'URL de la base de donn√©es. Cette variable est utilis√©e par Prisma pour se connecter √† la base de donn√©es.

Pour d√©finir une variable d'environnement, nous devons nous rendre dans le fichier `.env` et ajouter la variable `DATABASE_URL` si elle n'existe pas :

Pour Laragon :
```bash
DATABASE_URL="mysql://root@localhost:3306/{nom_de_la_base_de_donnees}"
```

Pour Mamp :
```bash
DATABASE_URL="mysql://root:root@localhost:8889/{nom_de_la_base_de_donnees}"
```



## Les Models de la base de donn√©es

Les mod√®les de la base de donn√©es sont des objets qui repr√©sentent les tables de la base de donn√©es. Ils sont utilis√©s pour d√©finir les relations entre les tables et pour d√©finir les types de donn√©es des colonnes.

Pour d√©finir un mod√®le de la base de donn√©es, nous allons cr√©er un fichier `schema.prisma` dans le dossier `prisma` de notre projet.

Dans ce fichier, nous allons d√©finir un mod√®le pour la table `users` :

```prisma
{
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User { // [!code ++]
  id        Int      @id @default(autoincrement()) // [!code ++]
  name      String // [!code ++]
  email     String   @unique // [!code ++]
  createdAt DateTime @default(now()) // [!code ++]
  updatedAt DateTime @updatedAt // [!code ++]
}
```

On a d√©fini un mod√®le pour la table `users` avec les champs suivants :

- `id` : l'identifiant unique de la table
- `name` : le nom de l'utilisateur
- `email` : l'adresse email de l'utilisateur
- `createdAt` : l'heure de cr√©ation de l'utilisateur
- `updatedAt` : l'heure de modification de l'utilisateur

<Cards>
 <Card title="Pourquoi utiliser autoincrement() ?" icon="ü§î"> 
 
 La fonction `autoincrement()` est utilis√©e pour g√©n√©rer automatiquement un identifiant unique pour chaque enregistrement. Cela permet de garantir l'unicit√© des identifiants et de g√©rer les conflits d'identifiants.
 
 </Card>

 <Card title="Pourquoi utiliser unique ?" icon="ü§î"> 
 
 La fonction `unique` est utilis√©e pour d√©finir que l'adresse email de l'utilisateur doit √™tre unique dans la table. Cela permet de garantir l'unicit√© des adresses email et de g√©rer les conflits d'adresses email.
 
 </Card>
</Cards>

Pour ensuite transferer les modifications de notre fichier `schema.prisma` vers la base de donn√©es, nous allons ex√©cuter la commande suivante :


```bash
npx prisma migrate dev --name init
```

```bash
npx prisma generate
```
Cette commande va g√©n√©rer le code JavaScript pour acc√©der √† la base de donn√©es et √† l'interface de programmation de la base de donn√©es.

Et voil√†, notre base de donn√©es est pr√™te √† √™tre utilis√©e avec Prisma !


## Utilisation de Prisma

Dans notre Controller `user.js` nous allons importer Prisma et utiliser les fonctions g√©n√©r√©es par Prisma pour acc√©der √† la base de donn√©es :

```js
import { PrismaClient } from '@prisma/client'; // [!code ++]

const prisma = new PrismaClient(); // [!code ++]
export default class UsersController {

    static async getUsers() {
        
        const names = ['John', 'Jane', 'Bob']; // [!code --]
        const users = await prisma.user.findMany(); // [!code ++]

        return { status: 200, message: 'getUsers', data: users };
    }

}
```

<Callout type="warn" title="Attention il faut importer des donn√©es !">
N'oubliez pas d'importer les donn√©es que vous souhaitez r√©cup√©rer dans votre mod√®le de la base de donn√©es.
</Callout>

Dans ce code nous avons import√© la classe `PrismaClient` qui permet de se connecter √† la base de donn√©es. Ensuite, nous avons cr√©√© une instance de la classe `PrismaClient` et assign√© la variable `prisma` √† cette instance.

Ensuite, nous avons utilis√© la fonction `findMany()` de la classe `PrismaClient` pour r√©cup√©rer tous les utilisateurs de la base de donn√©es.

A la fin nous obtenons un objet JSON avec le status 200, le message `getUsers` et les donn√©es des utilisateurs qui proviennent de la base de donn√©es.

### Utilisez Prisma Studio pour visualiser les donn√©es :

```bash
npx prisma studio
```
<Callout type="info" title="Bonnes pratiques"> 
- Versionnez toujours vos migrations 
- Utilisez des transactions pour les op√©rations complexes 
- Profitez du type-safe pour √©viter les erreurs 
- Documentez vos mod√®les avec des commentaires 
</Callout>


## Tester la route

Pour tester la route, ex√©cutez la commande suivante :

```bash
npm run dev
```

Vous pouvez maintenant acc√©der √† votre API en utilisant l'URL suivante :

```bash
http://localhost:3000/api/users/list
```
